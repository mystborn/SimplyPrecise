"""init

Revision ID: b4ca15ccfd41
Revises: 
Create Date: 2019-09-07 19:12:23.459331

"""
from alembic import op
import sqlalchemy as sa
import sqlalchemy_utils
from sqlalchemy_searchable import sync_trigger


# revision identifiers, used by Alembic.
revision = 'b4ca15ccfd41'
down_revision = None
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('tag',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('title', sa.String(length=64), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_tag_title'), 'tag', ['title'], unique=False)
    op.create_table('user',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('username', sa.String(length=64), nullable=True),
    sa.Column('password_hash', sa.String(length=128), nullable=True),
    sa.Column('about_me', sa.Text(), nullable=True),
    sa.Column('level', sa.Enum('normal', 'moderator', 'admin', name='userlevel'), nullable=True),
    sa.Column('is_verified', sa.Boolean(), nullable=True),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_user_username'), 'user', ['username'], unique=True)
    op.create_table('post',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('title', sa.Unicode(length=255), nullable=True),
    sa.Column('slug', sa.Text(), nullable=True),
    sa.Column('summary', sa.UnicodeText(), nullable=True),
    sa.Column('html_body', sa.UnicodeText(), nullable=True),
    sa.Column('markdown_body', sa.UnicodeText(), nullable=True),
    sa.Column('date_published', sa.DateTime(), nullable=True),
    sa.Column('date_edited', sa.DateTime(), nullable=True),
    sa.Column('user_id', sa.Integer(), nullable=True),
    sa.Column('search_vector', sqlalchemy_utils.types.ts_vector.TSVectorType(), nullable=True),
    sa.ForeignKeyConstraint(['user_id'], ['user.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    op.create_index(op.f('ix_post_date_published'), 'post', ['date_published'], unique=False)
    op.create_index('ix_post_search_vector', 'post', ['search_vector'], unique=False, postgresql_using='gin')
    op.create_index(op.f('ix_post_slug'), 'post', ['slug'], unique=False)
    op.create_table('tags',
    sa.Column('post_id', sa.Integer(), nullable=True),
    sa.Column('tag_id', sa.Integer(), nullable=True),
    sa.ForeignKeyConstraint(['post_id'], ['post.id'], ),
    sa.ForeignKeyConstraint(['tag_id'], ['tag.id'], )
    )
    sync_trigger(op.get_bind(), 'post', 'search_vector', ['title', 'summary', 'markdown_body'])
    op.execute("""
        DROP TYPE IF EXISTS tsq_state CASCADE;

        CREATE TYPE tsq_state AS (
            search_query text,
            parentheses_stack int,
            skip_for int,
            current_token text,
            current_index int,
            current_char text,
            previous_char text,
            tokens text[]
        );
        
        CREATE OR REPLACE FUNCTION tsq_append_current_token(state tsq_state)
        RETURNS tsq_state AS $$
        BEGIN
            IF state.current_token != '' THEN
                state.tokens := array_append(state.tokens, state.current_token);
                state.current_token := '';
            END IF;
            RETURN state;
        END;
        $$ LANGUAGE plpgsql IMMUTABLE;
        
        
        CREATE OR REPLACE FUNCTION tsq_tokenize_character(state tsq_state)
        RETURNS tsq_state AS $$
        BEGIN
            IF state.current_char = '(' THEN
                state.tokens := array_append(state.tokens, '(');
                state.parentheses_stack := state.parentheses_stack + 1;
                state := tsq_append_current_token(state);
            ELSIF state.current_char = ')' THEN
                IF (state.parentheses_stack > 0 AND state.current_token != '') THEN
                    state := tsq_append_current_token(state);
                    state.tokens := array_append(state.tokens, ')');
                    state.parentheses_stack := state.parentheses_stack - 1;
                END IF;
            ELSIF state.current_char = '"' THEN
                state.skip_for := position('"' IN substring(
                    state.search_query FROM state.current_index + 1
                ));
        
                IF state.skip_for > 1 THEN
                    state.tokens = array_append(
                        state.tokens,
                        substring(
                            state.search_query
                            FROM state.current_index FOR state.skip_for + 1
                        )
                    );
                ELSIF state.skip_for = 0 THEN
                    state.current_token := state.current_token || state.current_char;
                END IF;
            ELSIF (
                state.current_char = '-' AND
                (state.current_index = 1 OR state.previous_char = ' ')
            ) THEN
                state.tokens := array_append(state.tokens, '-');
            ELSIF state.current_char = ' ' THEN
                state := tsq_append_current_token(state);
            ELSE
                state.current_token = state.current_token || state.current_char;
            END IF;
            RETURN state;
        END;
        $$ LANGUAGE plpgsql IMMUTABLE;
        
        
        CREATE OR REPLACE FUNCTION tsq_tokenize(search_query text) RETURNS text[] AS $$
        DECLARE
            state tsq_state;
        BEGIN
            SELECT
                search_query::text AS search_query,
                0::int AS parentheses_stack,
                0 AS skip_for,
                ''::text AS current_token,
                0 AS current_index,
                ''::text AS current_char,
                ''::text AS previous_char,
                '{}'::text[] AS tokens
            INTO state;
        
            state.search_query := lower(trim(
                regexp_replace(search_query, '""+', '""', 'g')
            ));
        
            FOR state.current_index IN (
                SELECT generate_series(1, length(state.search_query))
            ) LOOP
                state.current_char := substring(
                    search_query FROM state.current_index FOR 1
                );
        
                IF state.skip_for > 0 THEN
                    state.skip_for := state.skip_for - 1;
                    CONTINUE;
                END IF;
        
                state := tsq_tokenize_character(state);
                state.previous_char := state.current_char;
            END LOOP;
            state := tsq_append_current_token(state);
        
            state.tokens := array_nremove(state.tokens, '(', -state.parentheses_stack);
        
            RETURN state.tokens;
        END;
        $$ LANGUAGE plpgsql IMMUTABLE;
        
        
        -- Processes an array of text search tokens and returns a tsquery
        CREATE OR REPLACE FUNCTION tsq_process_tokens(config regconfig, tokens text[])
        RETURNS tsquery AS $$
        DECLARE
            result_query text;
            previous_value text;
            value text;
        BEGIN
            result_query := '';
        
            FOREACH value IN ARRAY tokens LOOP
                IF value = '"' THEN
                    CONTINUE;
                END IF;
        
                IF value = 'or' THEN
                    value := ' | ';
                END IF;
        
                IF left(value, 1) = '"' AND right(value, 1) = '"' THEN
                    value := phraseto_tsquery(config, value);
                ELSIF value NOT IN ('(', ' | ', ')', '-') THEN
                    value := quote_literal(value) || ':*';
                END IF;
        
                IF previous_value = '-' THEN
                    IF value = '(' THEN
                        value := '!' || value;
                    ELSIF value = ' | ' THEN
                        CONTINUE;
                    ELSE
                        value := '!(' || value || ')';
                    END IF;
                END IF;
        
                SELECT
                    CASE
                        WHEN result_query = '' THEN value
                        WHEN previous_value = ' | ' AND value = ' | ' THEN result_query
                        WHEN previous_value = ' | ' THEN result_query || ' | ' || value
                        WHEN previous_value IN ('!(', '(') OR value = ')' THEN result_query || value
                        WHEN value != ' | ' THEN result_query || ' & ' || value
                        ELSE result_query
                    END
                INTO result_query;
                previous_value := value;
            END LOOP;
        
            IF result_query = ' | ' THEN
                RETURN to_tsquery('');
            END IF;
        
            RETURN to_tsquery(config, result_query);
        END;
        $$ LANGUAGE plpgsql IMMUTABLE;
        
        
        CREATE OR REPLACE FUNCTION tsq_process_tokens(tokens text[])
        RETURNS tsquery AS $$
            SELECT tsq_process_tokens(get_current_ts_config(), tokens);
        $$ LANGUAGE SQL IMMUTABLE;
        
        
        CREATE OR REPLACE FUNCTION tsq_parse(config regconfig, search_query text)
        RETURNS tsquery AS $$
            SELECT tsq_process_tokens(config, tsq_tokenize(search_query));
        $$ LANGUAGE SQL IMMUTABLE;
        
        
        CREATE OR REPLACE FUNCTION tsq_parse(config text, search_query text)
        RETURNS tsquery AS $$
            SELECT tsq_parse(config::regconfig, search_query);
        $$ LANGUAGE SQL IMMUTABLE;
        
        
        CREATE OR REPLACE FUNCTION tsq_parse(search_query text) RETURNS tsquery AS $$
            SELECT tsq_parse(get_current_ts_config(), search_query);
        $$ LANGUAGE SQL IMMUTABLE;
        
        
        -- remove first N elements equal to the given value from the array (array
        -- must be one-dimensional)
        --
        -- If negative value is given as the third argument the removal of elements
        -- starts from the last array element.
        CREATE OR REPLACE FUNCTION array_nremove(anyarray, anyelement, int)
        RETURNS ANYARRAY AS $$
            WITH replaced_positions AS (
                SELECT UNNEST(
                    CASE
                    WHEN $2 IS NULL THEN
                        '{}'::int[]
                    WHEN $3 > 0 THEN
                        (array_positions($1, $2))[1:$3]
                    WHEN $3 < 0 THEN
                        (array_positions($1, $2))[
                            (cardinality(array_positions($1, $2)) + $3 + 1):
                        ]
                    ELSE
                        '{}'::int[]
                    END
                ) AS position
            )
            SELECT COALESCE((
                SELECT array_agg(value)
                FROM unnest($1) WITH ORDINALITY AS t(value, index)
                WHERE index NOT IN (SELECT position FROM replaced_positions)
            ), $1[1:0]);
        $$ LANGUAGE SQL IMMUTABLE;
    """)
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('tags')
    op.drop_index(op.f('ix_post_slug'), table_name='post')
    op.drop_index('ix_post_search_vector', table_name='post')
    op.drop_index(op.f('ix_post_date_published'), table_name='post')
    op.drop_table('post')
    op.drop_index(op.f('ix_user_username'), table_name='user')
    op.drop_table('user')
    op.drop_index(op.f('ix_tag_title'), table_name='tag')
    op.drop_table('tag')
    op.execute('DROP TYPE public.userlevel')
    # ### end Alembic commands ###
